/****************************************************************
** helper definitions
*/
bypass(switch, block) = _ <: select2(switch, _, block);
BP(block) = bypass(checkbox("ON"), block);

copysign = ffunction(float copysign(float,float), <math.h>, "");

anti_denormal = pow(10,-20);
//add_dc = +(anti_denormal);
add_dc = +(anti_denormal);
anti_denormal_ac = 1 - 1' : *(anti_denormal) : + ~ *(-1);

smoothi(c) = *(1-c) : +~*(c);

clip(lo,hi) = min(hi) : max(lo);
sym_clip(thr) = clip(-thr,thr);

balance(b) = *(1 - max(0, b)), *(1 - max(0, -b));
wet_dry_mix(w, Fx) = _ <: _, Fx : balance(w) : +;


/****************************************************************
** nonlinear functions
*/

// from thesis of Ragnar Bendiksen (used in swh ladspa valve plugin)

valve = environment {
    ex(x) = (1 - exp(-x));
    nlim = 50; // exp(-nlim)+1 == 1, exp(nlim)/(exp(nlim)+1) == 1

    tr(x) = select2(abs(x) > eps, tr_taylor(x), tr_func(max(-600,x))) with
    {
        eps = pow(10,-4);
        tr_func(x) = select2(x < -nlim, x / ex(x), -x*exp(x));
        tr_taylor(x) = 1 + x/2 + x*x/12;
    };
    df(x) = select2(abs(x) > eps, df_taylor(x), df_func(max(-600,x))) with
    {
        eps = pow(10,-4);
        df_func(x) = select2(x < -nlim, 1/ex(x) - (x * exp(-x)) / (ex(x)*ex(x)), -x*exp(x));
        df_taylor(x) = 0.5 + x/6 - x*x*x/180;
    };
    qd(dist, q, x) = dist * (x - q);
    vt(dist, q, x) = (tr(qd(dist, q, x)) - tr(qd(dist, q, 0))) / dist;
    vt_scaled(dist, q, x) = select2(dist*q > nlim, vt(dist, q, x) / df(qd(dist, q, 0)), vt_lim(dist, q, x)) with
    {
        bigval = pow(10,10);
        f(dist, q, x) = (qd(dist, q, x)/(1 - exp(-qd(dist, q, x)))*exp(dist*q) - dist*q)/(dist*dist*q);
        vt_lim(dist, q, x) = select2(dist*x > nlim, select2(dist*x < -nlim, f(dist, q, x), -1/dist), bigval);
    };
    vts(dist, q, x) = abs(x) : neg : vt_scaled(dist, q) : copysign(_, x);
    vtu(dist, q, g) = vt_scaled(dist, q) : *(g) : neg : vt(dist, q) : neg;
    vtu_(dist, q, g) = vt_scaled(dist, q) :neg :  *(g) : vt_scaled(dist, q) : /(g) : neg;
};

saturate(t, x) = select2(abs(x) < t, x, v)
with {
  sigmoid(x) = x * (1.5 - 0.5 * x * x);
  sat(x) = t + (1 - t)*sigmoid((abs(x)-t)/((1-t)*1.5));
  v = copysign(x, sat(x));
};

nonlin(a,b,c,x) = ((a * x - b * abs(x) * x) - x) * c;
nonlin1 = nonlin(2,1,0.5);

/****************************************************************
 ** Guitar tone stacks
 ** values from CAPS plugin tonestack (based on work from D.T. Yeh
 */
ts = environment {
    k = *(1e3);
    M = *(1e6);
    nF = *(1e-9);
    pF = *(1e-12);

    /* Fender */

    bassman = environment { /* 59 Bassman 5F6-A */
	R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 56:k;
        C1 = 250:pF;
        C2 = 20:nF;
        C3 = 20:nF;
        };

    twin = environment { /* 69 Twin Reverb AA270 */
	R1 = 250:k;
        R2 = 250:k;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 120:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };

    princeton = environment { /* 64 Princeton AA1164 */
	R1 = 250:k;
        R2 = 250:k;
        R3 = 4.8:k;
        R4 = 100:k;
        C1 = 250:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };

    /* Marshall */

    jcm800 = environment { /* 59/81 JCM-800 Lead 100 2203 */
	R1 = 220:k;
        R2 = 1:M;
        R3 = 22:k;
        R4 = 33:k;
        C1 = 470:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
    /* 90 JCM-900 Master 2100: same as JCM-800 */

    jcm2000 = environment { /* 81 2000 Lead */
	R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 56:k; /* a 10 k fixed + 100 k pot in series actually */
        C1 = 500:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };

	/* parameter order is R1 - R4, C1 - C3 */
    mlead = environment { /* 67 Major Lead 200 */
	R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 33:k;
        C1 = 500:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };

    m2199 = environment { /* undated M2199 30W solid state */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 25:k;
        R4 = 56:k;
        C1 = 250:pF;
        C2 = 47:nF;
        C3 = 47:nF;
        };

    /* Vox */
    ac30 = environment { /* 59/86 AC-30 */
        /* R3 is fixed (circuit differs anyway) */
        R1 = 1:M;
        R2 = 1:M;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 50:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
};

tonestack(tse) = 1/A0*tf3(B0,B1,B2,B3,A1/A0,A2/A0,A3/A0) with {
    C1 = tse.C1;
    C2 = tse.C2;
    C3 = tse.C3;
    R1 = tse.R1;
    R2 = tse.R2;
    R3 = tse.R3;
    R4 = tse.R4;

    t = vslider("Treble", 0.5, 0, 1, 0.01);
    m = vslider("Middle", 0.5, 0, 1, 0.01);
    l = vslider("Bass", 0.5, 0, 1, 0.01) : (_-1)*3.4 : exp;

    b1 = t*C1*R1 + m*C3*R3 + l*(C1*R2 + C2*R2) + (C1*R3 + C2*R3);

    b2 = t*(C1*C2*R1*R4 + C1*C3*R1*R4) - m*m*(C1*C3*R3*R3 + C2*C3*R3*R3)
         + m*(C1*C3*R1*R3 + C1*C3*R3*R3 + C2*C3*R3*R3)
         + l*(C1*C2*R1*R2 + C1*C2*R2*R4 + C1*C3*R2*R4)
         + l*m*(C1*C3*R2*R3 + C2*C3*R2*R3)
         + (C1*C2*R1*R3 + C1*C2*R3*R4 + C1*C3*R3*R4);

    b3 = l*m*(C1*C2*C3*R1*R2*R3 + C1*C2*C3*R2*R3*R4)
         - m*m*(C1*C2*C3*R1*R3*R3 + C1*C2*C3*R3*R3*R4)
         + m*(C1*C2*C3*R1*R3*R3 + C1*C2*C3*R3*R3*R4)
         + t*C1*C2*C3*R1*R3*R4 - t*m*C1*C2*C3*R1*R3*R4
         + t*l*C1*C2*C3*R1*R2*R4;

    a0 = 1;

    a1 = (C1*R1 + C1*R3 + C2*R3 + C2*R4 + C3*R4)
         + m*C3*R3 + l*(C1*R2 + C2*R2);

    a2 = m*(C1*C3*R1*R3 - C2*C3*R3*R4 + C1*C3*R3*R3 + C2*C3*R3*R3)
         + l*m*(C1*C3*R2*R3 + C2*C3*R2*R3)
         - m*m*(C1*C3*R3*R3 + C2*C3*R3*R3)
         + l*(C1*C2*R2*R4 + C1*C2*R1*R2 + C1*C3*R2*R4 + C2*C3*R2*R4)
         + (C1*C2*R1*R4 + C1*C3*R1*R4 + C1*C2*R3*R4 + C1*C2*R1*R3 + C1*C3*R3*R4 + C2*C3*R3*R4);

    a3 = l*m*(C1*C2*C3*R1*R2*R3 + C1*C2*C3*R2*R3*R4)
         - m*m*(C1*C2*C3*R1*R3*R3 + C1*C2*C3*R3*R3*R4)
         + m*(C1*C2*C3*R3*R3*R4 + C1*C2*C3*R1*R3*R3 - C1*C2*C3*R1*R3*R4)
         + l*C1*C2*C3*R1*R2*R4
         + C1*C2*C3*R1*R3*R4;

    c = 2*float(SR);

    B0 = -b1*c - b2*pow(c,2) - b3*pow(c,3);
    B1 = -b1*c + b2*pow(c,2) + 3*b3*pow(c,3);
    B2 = b1*c + b2*pow(c,2) - 3*b3*pow(c,3);
    B3 = b1*c - b2*pow(c,2) + b3*pow(c,3);
    A0 = -a0 - a1*c - a2*pow(c,2) - a3*pow(c,3);
    A1 = -3*a0 - a1*c + a2*pow(c,2) + 3*a3*pow(c,3);
    A2 = -3*a0 + a1*c + a2*pow(c,2) - 3*a3*pow(c,3);
    A3 = -a0 + a1*c - a2*pow(c,2) + a3*pow(c,3);
};

/****************************************************************
** filter
*/

//---------------------second order Parametric Equalizer---------
// filter(Q,F,G)
//  			Q : quality factor [1..100]
//				F :	frequency (Hz)
//				G : gain [0..1]
//---------------------------------------------------------------
// from "bandfilter.dsp" in the faust2pd distribution 
// which was released under the BSD license.

eqfilter(Q,F,G)	= TF2(  (1 +  K/Q + K*K) 	/ D,
						 2 * (K*K - 1) 		/ D,
						(1 - K/Q + K*K) 	/ D,
						 2 * (K*K - 1) 		/ D,
						(1 - V*K/Q + K*K) 	/ D
					 )
		with {
				V = db2linear(G);
				K = tan(PI*F/SR);
				D = 1 + V*K/Q + K*K;
		};


ifilter(Q,F,G) = eqfilter(Q,F,-G);


/****************************************************************
** backward compatible faust library definitions, may removed when
** the good versions in wafscript where updated
*/

//----- frequency spliter (filterbank3) taken from faust-0.9.27 
//----- include here to be backward compatible to 0.9.24 

highpassN_plus_lowpassN(fc) = tf2s(1,-1,1,1,1,w1)
with { w1 = 2*PI*fc; };

filterbankN(lfreqs) = _ <: bsplit(nb) with
{
   nb = count(lfreqs);

   count ((xs, xxs)) = 1 + count(xxs);
   count (xx) = 1;

   take(1, (freq, lfreq)) = freq;
   take(1, freq) = freq;
   take(n, (freq, lfreq)) = take(n-1, lfreq);

   fc(n) = take(n, lfreqs);

   lp(n) = lowpass3(fc(n));  // 3rd-order Butterworth
   hp(n) = highpass3(fc(n));
   ap(n) = highpassN_plus_lowpassN(fc(n));

   bsplit(0) = _;
   bsplit(i) = (hp(i) : delayeq(i-1)), (lp(i) <: bsplit(i-1));

   delayeq(0) = _;
   delayeq(i) =  ap(i) : delayeq(i-1);
};

//----- Flanging effect renamed in faust-0.9.27 from
//----- flangermono -> flanger_mono
//----- flangerstereo -> flanger_stereo

flangermonoN(dmax,curdel,depth,fb,invert)
  = _ <: _, (-:fdelay(dmax,curdel)) ~ *(fb) : _, 
  *(select2(invert,depth,0-depth)) 
  : + : *(0.5);

flangerstereoN(dmax,curdel1,curdel2,depth,fb,invert)
  =  flangermonoN(dmax,curdel1,depth,fb,invert),
     flangermonoN(dmax,curdel2,depth,fb,invert);

//----- Moog "Voltage Controlled Filter" (VCF)
//----- filter renamed in faust-0.9.27 from
//----- moogvcf -> moog_vcf

import("filter.lib");

moogvcfN(res,fr) = (+ : seq(i,4,pole(p)) : *(unitygain(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * PI / SR; // good approximation for fr << SR
     unitygain(p) = pow(1.0-p,4.0); // one-pole unity-gain scaling
     mk = 0-4.0*max(0,min(res,0.999999)); // need mk > -4 for stability
};

/****************************************************************
** building blocks
*/
fuzzy_tube(a,b,c,fuzzy) = _ <: _ + nonlin(a,b,c) * fuzzy * 0.5 : sym_clip(0.7);
